<html>
<title>You only get one to exit</title>
<body style="margin: 0;" onresize="onResize();" onkeydown="onKeyDown(event);" onkeyup="onKeyUp(event);">
<canvas style="margin: 0;" id="main_canv" width="1" height="1"></canvas>
<script type="text/javascript">
var can = document.getElementById('main_canv');
var ctx = can.getContext("2d");

var real_canvas = document.createElement('canvas');
var real_ctx = real_canvas.getContext("2d");

var sprites = new Image();

var hit = document.createElement('audio');
var win = document.createElement('audio');

hit.src = "snd/hit.wav";
win.src = "snd/win.wav"

sprites.src = "img/sprites.png"

var square_width = 8;
var square_height = 8;
var SCREEN_WIDTH = 20;
var SCREEN_HEIGHT = 18;

var screen_dx = 0;
var screen_dy = 0;
var screen_multiplier = 1;

var WINDOW_WIDTH = 0;
var WINDOW_HEIGHT = 0;

real_canvas.width = SCREEN_WIDTH * square_width;
real_canvas.height = SCREEN_HEIGHT * square_height;

var GoodGameOver = {
	d: 0,
	init: function()
	{
		this.d = 0;
	},
	
	process: function()
	{
		GameState.process();
		if (this.d < 1.0)
		{
			this.d += 3 / 256;
		}
		else
		{
			Game.set_state(MenuState);
		}
	},
	
	key_up: function()
	{
		GameState.key_up();
	},
	
	key_down: function()
	{
		GameState.key_down();
	},
	
	draw: function(ctx)
	{
		GameState.draw(ctx);
		
		ctx.fillStyle="rgba(255,255,255,"+ this.d+")";
		ctx.fillRect(0,0, real_canvas.width, real_canvas.height);
	},
}

var BadGameOver = {
	d: 0,
	init: function()
	{
		this.d = 0;
	},
	
	process: function()
	{
		GameState.process();
		if (this.d < 1.0)
		{
			this.d += 3 / 256;
		}
		else
		{
			Game.set_state(MenuState);
		}
	},
	
	key_up: function()
	{
		GameState.key_up();
	},
	
	key_down: function()
	{
		GameState.key_down();
	},
	
	draw: function(ctx)
	{
		GameState.draw(ctx);
		
		ctx.fillStyle="rgba(0,0,0,"+ this.d+")";
		ctx.fillRect(0,0, real_canvas.width, real_canvas.height);
	},
}


var GameState = {

	end: false,
	keys: 0,
	
	swarm: [],
	
	max_d: 2.5,
	
	plX: real_canvas.width / 2,
	plY: real_canvas.height / 2,
	
	dy: 0,
	
	start_of_the_end: 5,
	
	where_end_is: null,
	
	is_escaped: 0,

	init: function()
	{
		this.where_end_is = null,
		this.is_escaped = 0,
		
		this.plX = real_canvas.width / 2;
		this.plY = real_canvas.height / 2;
		for (var i = 0; i < 20; i++)
		{
			this.swarm.push({x: this.plX + Math.random() * 20 - 10, y: this.plY + Math.random() * 20 - 10, dx: 0, dy: 0});
		}
		
		this.step = 0;
		this.dy = 0;
		this.level = 1;
		
		this.blocks = [];
		this.end = false;
		
		this.keys = 0;
	},
	
	step: 0,
	level: 1,
	
	blocks: [],
	
	process: function()
	{
	
		if (this.level >= this.start_of_the_end)
		{
			if (this.where_end_is == null)
			{
				this.where_end_is = real_canvas.width;
			}
			
			this.where_end_is -= 1;
		}
	
		// game over?
		if (this.swarm.length == 0 && !this.end)
		{
			this.end = true;
			if (!this.is_escaped)
			{
				Game.set_state(BadGameOver);
			}
			else
			{
				Game.set_state(GoodGameOver);
			}
		}
		
		this.step += 1;
		
		// add blocks;
			// Add walls
			if (this.step % square_width == 0)
			{
				for (var i = 0; i < this.level; i++)
				{
					this.blocks.push({x: real_canvas.width, y: square_height * i, w: square_width, h: square_height, t: Math.floor(Math.random()*3)})
					
					this.blocks.push({x: real_canvas.width, y: real_canvas.height - square_height - square_height * i, w: square_width, h: square_height, t: Math.floor(Math.random()*3)})
				}
			}
			
			// free blocks
			if (this.step % (square_width * 5) == 0)
			{
				this.blocks.push({x: real_canvas.width, y: Math.random() * real_canvas.height, w: square_width, h: square_height, t: Math.floor(Math.random()*3)})
			}
			
		// add level:
			if (this.step % (square_width * 90) == 0)
			{
				this.level += 1;
			}
		
		// move blocks and swarm
		var tb = [];
		var ts = [];
		for (var i in this.blocks)
		{
			this.blocks[i].x -= 1;
			
			if (this.blocks[i].x > - square_width)
			{
				tb.push(this.blocks[i]);
			}
			
			for (var j in this.swarm)
			{
				if ((
					( (this.blocks[i].x < this.swarm[j].x) && (this.swarm[j].x < (this.blocks[i].w + this.blocks[i].x))) &&
					( (this.blocks[i].y < this.swarm[j].y) && (this.swarm[j].y < (this.blocks[i].h + this.blocks[i].y)))
				   )
				   ||
				   ((this.swarm[j].y < 0 || this.swarm[j].y > real_canvas.height) && !this.end)
				   )
				 {
					ts[j] = true;
				 }
				 
				 if (this.where_end_is!= null && this.swarm[j].x > this.where_end_is)
				 {
					this.swarm[j].escaped = true;
					ts[j] =true;
				 }
			}
		}
		
		var tmps  = [];
		for (var j in this.swarm)
		{
			if (!ts[j])
			{
				tmps.push(this.swarm[j]);
			}
			else
			{
				if (this.swarm[j].escaped)
				{
					this.is_escaped += 1;
					win.play();
				}
				else
				{
					hit.play();
				}
			}
		}
		
		this.swarm = tmps;
		this.blocks = tb;
		
		// move spot
		if (!Game.is_key_pressed())
		{
			this.dy += .1;
			
			if (this.dy > this.max_d)
				this.dy = this.max_d;
		}
		else
		{
			this.dy -= .2;
			
			if (this.dy < - this.max_d)
				this.dy = - this.max_d;
		}
		
		this.plY += this.dy;
		
		// move swarm to spot:
		for (var i in this.swarm)
		{
			if (this.swarm[i].x > this.plX)
			{
				this.swarm[i].dx -= .1;
				
				if (this.swarm[i].dx < - this.max_d) this.swarm[i].dx = -this.max_d
			}
			
			if (this.swarm[i].x < this.plX)
			{
				this.swarm[i].dx += .1;
				
				if (this.swarm[i].dx > this.max_d) this.swarm[i].dx = this.max_d
			}
			
			if (this.swarm[i].y > this.plY)
			{
				this.swarm[i].dy -= .1;
				if (this.swarm[i].dy < - this.max_d) this.swarm[i].dy = -this.max_d
			}
			
			if (this.swarm[i].y < this.plY)
			{
				this.swarm[i].dy += .1;
				if (this.swarm[i].dy > this.max_d) this.swarm[i].dy = this.max_d
			}
			
			this.swarm[i].x += this.swarm[i].dx;
			this.swarm[i].y += this.swarm[i].dy;
			
			
		}
	},
	
	draw: function(ctx)
	{
		// blue background
		ctx.fillStyle="rgb(0,0,128)";
		ctx.fillRect(0,0,real_canvas.width, real_canvas.height);
		
		// blocks:
		ctx.fillStyle="rgb(0,255,0)";
		for (var i in this.blocks)
		{	
			var t = this.blocks[i].t * 8;
			//ctx.fillRect(this.blocks[i].x, this.blocks[i].y, this.blocks[i].w, this.blocks[i].h);
			ctx.drawImage(sprites, t, 0, 8, 8, this.blocks[i].x, this.blocks[i].y, 8, 8);
		}
		
		// END:
		ctx.fillStyle="rgba(255,0, 0, 0.4)";
		if (this.where_end_is != null)
		{
			ctx.fillRect(this.where_end_is, 0, real_canvas.width * 2, real_canvas.height);
		}
		
		// spot
		ctx.fillStyle="rgba(255,0,0, 0.5)";		
		//ctx.fillRect(this.plX - 3, this.plY - 3, 6, 6);
		ctx.drawImage(sprites, 16, 8, 8, 8, this.plX - 4, this.plY - 4, 8, 8);
		
		
		// fleas
		ctx.strokeStyle="#FFFF66";
		for (var i in this.swarm)
		{
			/*
			ctx.beginPath();
			ctx.moveTo(this.swarm[i].x, this.swarm[i].y);
			ctx.lineTo(this.swarm[i].x+1, this.swarm[i].y)
			ctx.stroke();
			*/
			var t = Math.floor(Math.random()*2);
			ctx.drawImage(sprites, t, 8, 8, 8, this.swarm[i].x - 4, this.swarm[i].y - 4, 8, 8);
		}
	},
	
	key_down: function()
	{
		this.keys++;
	},
	
	key_up: function()
	{
		if (this.keys > 0)
		{
			this.keys --;
		}
	}
}

var MenuToGameState = {
	init: function()
	{
		this.d = 0;
		this.c = 0;
	},
	
	process: function()
	{
		MenuState.process(ctx);
		
		if (this.d < 256)
		{
			this.d += 4;
		}
		else
		{
			Game.set_state(GameState);
		}
	},
	
	key_down: function()
	{
	
	},
	
	key_up: function()
	{
	
	},
	
	draw: function(ctx)
	{
		MenuState.draw(ctx);
		ctx.fillStyle="rgba(0,0,0,"+(this.d / 256)+ ")"; //
		ctx.fillRect(0, 0, real_canvas.width, real_canvas.height);
	}
}

var MenuState = {
	init: function()
	{
		this.yoge_angle = 0;
		this.pak_angle = 0;
	},
	
	process: function()
	{
		this.yoge_angle += 0.01;
		this.pak_angle -= 0.07;
	},
	
	key_down: function(code)
	{
		Game.set_state(MenuToGameState);
	},
	
	key_up: function(code)
	{
		
	},
	
	draw: function(ctx)
	{
		ctx.save();
		ctx.textBaseline = "middle";
		ctx.textAlign = "center";
		ctx.translate(SCREEN_WIDTH * square_width /2, SCREEN_HEIGHT * square_height / 3);
		ctx.rotate(this.yoge_angle);
		
		var t = "You only get one to exit";
		var c = "rgb(0,0,0)";
		
		if (GameState.is_escaped > 0)
		{
			var t = "Congratulations! You only get " + GameState.is_escaped + " to exit!";
			var c = "rgb(128,0,0)";
		}
		
		ctx.fillStyle = c;
		ctx.fillText(t, 0, 0);
		ctx.restore();
		
		ctx.fillStyle = "black";
		
		ctx.save();
		ctx.textBaseline = "middle";
		ctx.textAlign = "center";
		ctx.translate(SCREEN_WIDTH * square_width /2, SCREEN_HEIGHT * square_height / 2);
		ctx.rotate(this.pak_angle);
		ctx.fillText("Press any key", 0, 0);
		ctx.restore();
	}
}

var Game = {
	dt: new Date(),
	fps: 1000 / 30,
	time_debt: 0,
	
	state: MenuState,
	
	keys: [],
	
	key_down: function(code)
	{
		if (!this.keys[code])
		{
				this.state.key_down(code);
		}
		this.keys[code] = true;
	},
	
	key_up: function(code)
	{
		this.keys[code] = false;
		this.state.key_up(code);
	},
	
	is_key_pressed: function ()
	{
		for (var i in this.keys)
		{
			if (this.keys[i])
			{
				return true;
			}
		}
		
		return false;
	},
	
	process: function()
	{
		nd = new Date();
		dt = nd - this.dt;
		this.dt = nd;
		
		this.time_debt += dt;
		
		while (this.time_debt > this.fps)
		{
			this.time_debt -= this.fps;
			this.state.process();
		}
	},
	
	draw: function(ctx)
	{
		ctx.beginPath();
		ctx.rect(0, 0, SCREEN_WIDTH * square_width, SCREEN_HEIGHT * square_height);
		ctx.stroke();
		
		this.state.draw(ctx);
	},
	
	set_state: function (state)
	{
		state.init();
		this.state = state;
	}
}

function onDraw()
{
	can.width = WINDOW_WIDTH;
	can.height = WINDOW_HEIGHT;
	
	ctx.translate(screen_dx, screen_dy);
	ctx.scale(screen_multiplier, screen_multiplier);
	
	real_canvas.width = real_canvas.width;
	Game.draw(real_ctx);
	ctx.drawImage(real_canvas, 0, 0);
}

function onResize()
{
	WINDOW_WIDTH = window.innerWidth;
	WINDOW_HEIGHT = window.innerHeight;
	
	for (screen_multiplier = 2; (SCREEN_WIDTH*square_width*screen_multiplier <= WINDOW_WIDTH) && (SCREEN_HEIGHT*square_height*screen_multiplier <= WINDOW_HEIGHT) ; screen_multiplier++)
		continue;
	screen_multiplier--;
	
	screen_dx = (WINDOW_WIDTH - SCREEN_WIDTH*square_width*screen_multiplier) / 2;
	screen_dy = (WINDOW_HEIGHT - SCREEN_HEIGHT*square_height*screen_multiplier) / 2;
}

function onKeyUp(event)
{
	Game.key_up(event.keyCode);
}

function onKeyDown(event)
{
	Game.key_down(event.keyCode);
}

function setup()
{
	Game.set_state(MenuState);
}

function run()
{
	Game.process();
	onDraw();
	window.setTimeout(run, 1);
}

onResize();

setup();
run();
</script>
</body>
</html>